[{"title":"拥抱生活","url":"/2021/09/07/%E6%8B%A5%E6%8A%B1%E7%94%9F%E6%B4%BB/","content":"&nbsp;&nbsp;生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义，但是人生不可能没有意义，因为当你认为没意义的时候，一定有一个与之相对应的概念叫有意义。\n&nbsp;&nbsp;彻底的怀疑主义在逻辑上是完全错误的，我们脚掌所踏的大地是坚实的，我们不可能永远漂浮在空中，所以不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n&nbsp;&nbsp;人类所有的真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动，所有真实的快乐都需要长久的铺垫与努力，没有辛勤的汗水，幸福也就不在成为幸福，如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可以抛弃，因此对于年轻人而言，一个重要的功课就是要学会去节制欲望。\n&nbsp;&nbsp;最好的厨子就是饥饿，如果每天都是大吃大喝，每天都是饕餮盛宴，人一定会失去对所有食物的胃口。\n&nbsp;&nbsp;所有通过捷径带来的快乐，最终都会让人失去志向，因为快乐来的太便捷，以致于所有的追求都变得毫无意义，人生也就了无生趣，所有幻想着通过捷径来体验快乐的尝试，最终带来的一定是痛苦和虚无，在每天真实的努力中去拥抱人生的意义，去追寻真实的快乐。\n\n\n文章摘录自B站罗翔说刑法\n\n","categories":["生活"]},{"title":"排序算法","url":"/2021/09/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":"基本概念排序（sort），就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。稳定性，关键字相同的元素经过排序后行对顺序是否会改变。\n插入排序（Insertion Sort）算法思想每次将一个带排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。\n算法实现// 直接插入排序void Insertsort(int A[],int n)&#123;   int i,j,temp;   for(i=1;i&lt;n;i++)        //将各元素插入已排好的序列中       if(A[i]&lt;A[i-1])&#123;   //若A[i]关键字小于前驱           temp=A[i];      //用temp暂存A[i]\t\t   for(j=i-1;j&gt;=0 &amp;&amp; A[j]&gt;temp;--j) //检查前面所有已排好的元素\t\t        A[j+1]=a[j]; //所有大于temp的元素后移\t\t    A[j+1]=temp;     //复制到插入位置\t\t&#125;\t&#125;//直接插入排序（带哨兵）  void Insertsort(int A[],int n)   int i,j;   for(i=2;i&lt;=n;i++)       //依次将A[2]~A[n]插入到前面已排序序列        if(A[i]&lt;A[i-1]&#123;    //若A[i]小于其前驱，将A[i]插入有序列表\t\tA[0]=A[i];         //复制为哨兵，A[0]不存放元素\t\tfor(j=i-1;A[0]&lt;A[j];--j) //从后往前查找待插入位置\t\t   A[j+1]=A[j];    //向后挪位\t\tA[j+1]=A[0];       //复制到插入位置\t\t&#125;\t&#125;\n哨兵的优点在于：不用每轮循环都判断j&gt;=0\n算法效率分析空间复杂度：O(1)时间复杂度：主要来自对比关键字、移动元素，若有n个元素，则需要n-1趟处理最好情况：共n-1趟处理，每趟只需对比关键字一次，不需要移动元素，最好时间复杂度为O(n)最坏情况：第一趟：对比关键字2次，移动元素3次          第二趟：对比关键字3次，移动元素4次          …          第n-1趟：对比关键字n次，移动元素n+1次         最坏时间复杂度O(n^2)平均时间复杂度：O(n^2)稳定性：稳定\n优化-折半查找排序折半查找到应插入的位置，仅用于顺序表注意：一直到low=high时才停止折半查找。当mid所指元素等于当前元素时，应继续令low=mid+1,以保证稳定性。最终应将当前元素插入到low所指位置（即high+1）。\n//折半插入排序void IsertSort(int A[],int n)&#123;      int i,j,low,high,mid;     \t  for(i=2;i&lt;=n;i++)&#123;      //依次将A[2]~A[n]插入到前面已排序序列\t      A[0]=A[i];          //将A[i]暂存到A[0]\t\t  low=1,high=i-1;     //设置折半查找的范围\t\t  while(low&lt;=high)&#123;   //折半查找\t\t      mid=(low+high)/2; //取中间点\t\t\t  if(A[mid]&gt;A[0])   \t\t\t  high=mid-1;      //查找左半子表\t\t\t  else low=mid+1;  //查找右半子表\t\t&#125;\t\tfor(j=i-1;j&gt;=high+1;--j)\t\t   A[j+1]=A[j];        //统一后移元素，空出插入位置\t\t A[high+1]=A[0];      \t &#125;\n虽然比较关键字次数减少了，但移动元素次数没变，时间复杂度O(n^2)\n对链表的插入排序。。。移动元素的次数减少了，但关键字对比的次数依然是O(n^2)数量级，整体来看时间复杂度依然是o(n^2)\n希尔排序(Shell Sort)算法思想 先将带排序表分割成若干形如L[i,i+d,i+2d,…,i+kd]的“特殊”子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。 \n算法实现 //希尔排序void ShellSort(int A[],int n)&#123;     int d,i,j;  //A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置为j+d  for(d= n/2;d&gt;=1;d=d/2)&#123;       //步长变化       for(i=d+1;i&lt;=n;++i)\t       if(A[i]&lt;A[i-d])&#123;     //需将A[i]插入有序增量子表\t\t       A[0]=A[i];       //暂存于A[0]\t\t\t   for(j=i-d;j&gt;0 &amp;&amp; A[0]&lt;A[j]；j-=d)\t\t\t      A[j+d]=A[j]；   //记录后移，查找插入的位置\t\t\t\tA[j+d]=A[0];      //插入\t\t  &#125;   // if&#125;\n算法性能排序空间复杂度：O(1)时间复杂度：和增量序列d_1,d_2,d_3…有关，无法用数学手段证明确切的时间复杂度。稳定性：不稳定！适用性：仅适用于顺序表，不适用于链表\n交换排序基于“交换”的排序：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。包含冒泡排序和快速排序。\n冒泡排序（Bubble Sort）算法思想从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]）,则交换它们，直到序列比较完，称这样的过程为“一趟”冒泡排序。每一趟都能使一个元素到达最终位置\n算法实现//交换void swap(int &amp;a,int &amp;b)&#123;      int temp=a;\t  a=b;\t  b=temp;\t&#125;//冒泡排序void BubbleSort(int A[],int n)&#123;     for(int i=0;i&lt;n-1;i++)&#123;\t     bool flag=false;       //表示本趟排序是否发生交换的标志\t\t for(int j=n-1;j&gt;1;j--) //一趟排序过程\t\t    if(A[j-1]&gt;A[j])&#123;     //若为逆序 \t\t\t   swap(A[j-1],A[j]); //交换 \t\t\t   flag=true;\t\t\t &#125;\t\tif(flag=false)return; //本趟遍历未发生交换，说明已经有序\t\t&#125;&#125;\n算法效率分析空间复杂度：O(1)时间复杂度：最好情况（有序）O(n) ，比较次数=n-1；交换次数0            最坏情况（逆序）O(n^2)，比较次数=(n-1)+(n-2)+…+1=n(n-1)/2=交换次数            平均时间复杂度：O（n^2）每次用swap交换都要移动元素3次稳定性：稳定\n冒泡排序链表实现…\n","tags":["数据结构","排序"]},{"title":"谁不是一边努力，一边想放弃","url":"/2021/09/11/%E8%B0%81%E4%B8%8D%E6%98%AF%E4%B8%80%E8%BE%B9%E5%8A%AA%E5%8A%9B%EF%BC%8C%E4%B8%80%E8%BE%B9%E6%83%B3%E6%94%BE%E5%BC%83/","content":"对于很多在大城市生活的人们而言，打拼很久才能买得起那里的一套房，但是他们还是愿意在那个最高的地方步履匆匆，逆流而上。因为他们执着于的，从不是一个结果，而是在这个城市里所富集的资源是小城市远远比不了的。后来我也明白，每一个在这个宇宙中生存着的人，都相应有一颗星星在天边闪耀。有的，一生矢志不渝只为了做最亮的那一颗，穿越亿万光年，要你记住它的光和亮。为此他们不断切割自己，练就八面玲珑一身铠甲，只为了被某一些素不相识的记得。而有的，奔波劳碌只为了做浩瀚星空的一抹点缀，散发着消隐地只余下淡淡的影绰。无意苦争春，只想做英雄路过时身边鼓掌的人。没有谁比谁容易，也没有谁比谁高明。而是沉默的人自动安静，喧哗的人自然放声。既然有语不惊人死不休的轰轰烈烈，也必定有风雨飘摇浮萍如寄只求安稳度日的柴米油盐。人这一辈子，其实就是不断地选择与迁徙。在大城市打拼的匆匆忙忙，在云海深处的悠悠哉哉。没有哪一种生活该成为苟且的理由，因为一旦你以“苟且”冠之，你就真的开始苟且了。生活是充满妥协，但是感情永远不要将就。如果说妥协是卧薪尝胆，那么将就就是隔江犹唱后庭花。妥协是暂时的弯腰，而将就是一辈子的低头。将就这件事，就像说谎一样。一旦开始，就无法自主，一坑更比一坑深。得到再失去和从不曾拥有到底哪一个更痛苦一些?如果是以前，我选第一个。而现在，我宁愿选第二个。我们总害怕结局的不如人意和努力的徒劳无功。这是人之常情，却非生活。生活的意义，不全在于终点的欢呼、奖杯和荣耀。倒是中途每一次补给站的重新出发更让人热血沸腾。我们总说理性比较重要，可是决定我们一生中重要转折的瞬间，往往都是感性做主。理智可以战胜情感，但情感可以战胜所有。如果可以，不要将就着，选最好的，不回头地追最爱的。你只管走自己的路。同时允许别人走他们的路。错综复杂，偶尔理智偶尔癫狂，时常喋喋不休时常安静疏离，这才是生活。一边喊着要放弃，一边复习到深夜。被自己气哭的那个夜晚，又笑着拿起纸笔，这才是考研。总之岁月漫长，然而值得等待愿今后的每一天都有梦想照亮我们前方的路愿我们饱经现实锤炼但依旧不忘初心愿我们都能在时光的洗礼下成长为真正的大人愿岁月不负你我———考研人\n","categories":["生活"],"tags":["考研","随笔"]}]